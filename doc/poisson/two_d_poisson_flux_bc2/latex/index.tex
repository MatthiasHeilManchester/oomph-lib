In this document, we discuss an alternative approach for solving the 2D Poisson problem\+: \begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Two-\/dimensional model Poisson problem with Neumann boundary conditions}} \end{center}  Solve \[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = f(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (1) \] in the rectangular domain $D = \left\{ (x_1,x_2) \in [0,1] \times [0,2]\right\} $. The domain boundary $ \partial D = \partial D_{Neumann} \cup \partial D_{Dirichlet} $, where $ \partial D_{Neumann} = \left\{ (x_1,x_2) | x_1=1, \ x_2\in [0,2] \right\} $. On $ \partial D_{Dirichlet}$ we apply the Dirichlet boundary conditions \[ \left. u\right|_{\partial D_{Dirichlet}}=u_0, \ \ \ \ \ \ \ \ \ \ (2) \] where the function $ u_0 $ is given. On $ \partial D_{Neumann}$ we apply the Neumann conditions \[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}} = \left. \frac{\partial u}{\partial x_1}\right|_{\partial D_{Neumann}} =g_0, \ \ \ \ \ \ \ \ \ \ (3) \] where the function $ g_0 $ is given.   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center}  ~\newline


In a \href{../../two_d_poisson_flux_bc/html/index.html}{\texttt{ previous example,}} we applied the Neumann boundary conditions by adding {\ttfamily Poisson\+Flux\+Elements} (elements that apply the Neumann (flux) boundary conditions on surfaces of higher-\/dimensional \char`\"{}bulk\char`\"{} Poisson elements) to the {\ttfamily Problem\textquotesingle{}s} {\ttfamily Mesh} object. The ability to combine elements of different types in a single {\ttfamily Mesh} object is convenient, and in certain circumstances absolutely essential, but it can cause problems; see the discussion of the {\ttfamily doc\+\_\+solution(...)} function in the \href{../../two_d_poisson_flux_bc/html/index.html}{\texttt{ previous example}}. Furthermore, it seems strange (if not wrong!) that the {\ttfamily Simple\+Rectangular\+Quad\+Mesh} -- an object that is templated by a particular (single!) element type -- also contains elements of a different type.

We shall now demonstrate an alternative approach, based on the use of multiple meshes, each containing only one type of element. The ability to use multiple {\ttfamily Meshes} in a single {\ttfamily Problem} is an essential feature of {\ttfamily oomph-\/lib} and is vital in fluid-\/structure interaction problems, where the fluid and solid domains are distinct and each domain is discretised by a different element type.

We consider the same problem as in the \href{../../two_d_poisson_flux_bc/html/index.html}{\texttt{ previous example}} and choose a source function and boundary conditions for which the function \[ u_0(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)), \ \ \ \ \ \ \ \ \ (4) \] is the exact solution of the problem.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{soln}
\doxyfigcaption{Plot of the solution }
\end{DoxyImage}


\DoxyHorRuler{0}
 ~\newline
 \DoxyHorRuler{0}
\hypertarget{index_global}{}\doxysection{Global parameters and functions}\label{index_global}
The specification of the source function and the exact solution in the namespace {\ttfamily \mbox{\hyperlink{namespaceTanhSolnForPoisson}{Tanh\+Soln\+For\+Poisson}}} is identical to that in the single-\/mesh version discussed in the \href{../../two_d_poisson_flux_bc/html/index.html}{\texttt{ previous example}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The driver code}\label{index_main}
The driver code is identical to that in the single-\/mesh version discussed in the \href{../../two_d_poisson_flux_bc/html/index.html\#main}{\texttt{ previous example}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{The problem class}\label{index_problem}
The problem class is virtually identical to that in the \href{../../two_d_poisson_flux_bc/html/index.html\#problem}{\texttt{ single-\/mesh implementation}}\+: The only difference is that we store pointers to the two separate {\ttfamily Mesh} objects as private member data, and provide a slightly different implementation of the function {\ttfamily create\+\_\+flux\+\_\+elements(...)}.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//========= start\_of\_problem\_class=====================================}}
\DoxyCodeLine{\textcolor{comment}{/// 2D Poisson problem on rectangular domain, discretised with}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// 2D QPoisson elements. Flux boundary conditions are applied}}
\DoxyCodeLine{\textcolor{comment}{/// along boundary 1 (the boundary where x=L). The specific type of }}
\DoxyCodeLine{\textcolor{comment}{/// element is specified via the template parameter.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> }
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classTwoMeshFluxPoissonProblem}{TwoMeshFluxPoissonProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: Pass pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_ace5a47aa61da5fd2a8761a16ffb3711c}{TwoMeshFluxPoissonProblem}}(PoissonEquations<2>::PoissonSourceFctPt source\_fct\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a03e83ef12db3bf5a1e015c3c3b11337c}{\string~TwoMeshFluxPoissonProblem}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution. DocInfo object stores flags/labels for where the}}
\DoxyCodeLine{\textcolor{comment}{ /// output gets written to}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a6320ad6d71f24a2d7e03a7bb7e691b31}{doc\_solution}}(DocInfo\& doc\_info);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve: Reset boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{ /// to the values from the exact solution.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a520768a954d00d3972115ccf0b304854}{actions\_before\_newton\_solve}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs after solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a9b3da753ba1d924b920e2e67779e7453}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// \(\backslash\)short Create Poisson flux elements on boundary b of the Mesh pointed}}
\DoxyCodeLine{\textcolor{comment}{ /// to by bulk\_mesh\_pt and add them to the Mesh object pointed to by }}
\DoxyCodeLine{\textcolor{comment}{ /// surface\_mesh\_pt}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a6729e6d9cf920e0880603fa9920ab28c}{create\_flux\_elements}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&b, Mesh* \textcolor{keyword}{const} \&bulk\_mesh\_pt,}
\DoxyCodeLine{                           Mesh* \textcolor{keyword}{const} \&surface\_mesh\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the "{}bulk"{} mesh}}
\DoxyCodeLine{\textcolor{comment}{} SimpleRectangularQuadMesh<ELEMENT>* \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_abd0718261b6c8586d5de35cfef2292d8}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the "{}surface"{} mesh}}
\DoxyCodeLine{\textcolor{comment}{} Mesh* \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a96b1ff6102eceb5ce432ac9197f68283}{Surface\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} PoissonEquations<2>::PoissonSourceFctPt \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a56a27b0dbf0f5975a4b9d37f3985c364}{Source\_fct\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of problem class}}

\end{DoxyCodeInclude}
 \mbox{[}See the discussion of the \href{../../one_d_poisson/html/index.html}{\texttt{ 1D Poisson problem}} for a more detailed discussion of the function type Poisson\+Equations$<$2$>$\+::\+Poisson\+Source\+Fct\+Pt.\mbox{]}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{The Problem constructor}\label{index_constructor}
As before we start by creating the \char`\"{}bulk\char`\"{} mesh and store a pointer to this mesh in the private data member {\ttfamily \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_abd0718261b6c8586d5de35cfef2292d8}{Two\+Mesh\+Flux\+Poisson\+Problem\+::\+Bulk\+\_\+mesh\+\_\+pt}}\+:} 


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 Next, we construct an (empty) {\ttfamily Mesh} and store a pointer to it in the private data member {\ttfamily \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a96b1ff6102eceb5ce432ac9197f68283}{Two\+Mesh\+Flux\+Poisson\+Problem\+::\+Surface\+\_\+mesh\+\_\+pt}}}.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 We use the function {\ttfamily create\+\_\+flux\+\_\+elements(...)}, to create the prescribed-\/flux elements for the elements on boundary 1 of the bulk mesh and add them to the surface mesh.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 We have now created all the required elements and can access them directly via the two data members {\ttfamily \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_abd0718261b6c8586d5de35cfef2292d8}{Two\+Mesh\+Flux\+Poisson\+Problem\+::\+Bulk\+\_\+mesh\+\_\+pt}}} and {\ttfamily \mbox{\hyperlink{classTwoMeshFluxPoissonProblem_a96b1ff6102eceb5ce432ac9197f68283}{Two\+Mesh\+Flux\+Poisson\+Problem\+::\+Surface\+\_\+mesh\+\_\+pt}}}. However, many of {\ttfamily oomph-\/lib\textquotesingle{}s} generic procedures require ordered access to {\itshape all} of the {\ttfamily Problem\textquotesingle{}s} elements, nodes, etc. For instance, {\ttfamily Problem\+::newton\+\_\+solve(...)} computes the entries in the global Jacobian matrix by adding the contributions from all elements in all (sub-\/)meshes. Ordered access to the {\ttfamily Problem\textquotesingle{}s} elements, nodes, etc is generally obtained via the {\ttfamily Problem\textquotesingle{}s} (single!) global {\ttfamily Mesh} object, which is accessible via {\ttfamily Problem\+::mesh\+\_\+pt()}. The {\ttfamily Problem} base class also provides a private data member {\ttfamily Problem\+::\+Sub\+\_\+mesh\+\_\+pt} (a vector of type {\ttfamily Vector$<$\+Mesh$\ast$$>$}) which stores the (pointers to the) {\ttfamily Problem\textquotesingle{}s} sub-\/meshes. We must add the pointers to our two sub-\/meshes to the problem,


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 and use the function {\ttfamily Problem\+::build\+\_\+global\+\_\+mesh()} to combine the {\ttfamily Problem\textquotesingle{}s} sub-\/meshes into a single, global {\ttfamily Mesh} that is accessible via {\ttfamily Problem\+::mesh\+\_\+pt()}\+:


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 The rest of the constructor is identical to that in the \href{../../two_d_poisson_flux_bc/html/index.html}{\texttt{ single-\/mesh implementation}}. We pin the nodal values on the Dirichlet boundaries, pass the function pointers to the elements, and set up the equation numbering scheme\+:


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_actions_before}{}\doxysection{\char`\"{}\+Actions before solve\char`\"{}}\label{index_actions_before}
The only (minor) change to {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} is that the nodes on the boundaries of the bulk (!) mesh are now obtained via the {\ttfamily Bulk\+\_\+mesh\+\_\+pt} pointer, rather than from the combined {\ttfamily Mesh}, pointed to by {\ttfamily Problem\+::mesh\+\_\+pt()}. While this may appear to be a trivial change, it is a potentially important one. Recall that the surface mesh is an instantiation of the {\ttfamily Mesh} base class. We created the (empty) mesh in the {\ttfamily Problem} constructor (by calling the default {\ttfamily Mesh} constructor), and used the function {\ttfamily create\+\_\+flux\+\_\+elements(...)} to add the (pointers to the) prescribed-\/flux elements to it. The surface mesh therefore does not have any nodes of its own, and its lookup schemes for the boundary nodes have not been set up. The combined mesh, pointed to by {\ttfamily Problem\+::mesh\+\_\+pt()}, therefore only contains the boundary lookup scheme for the bulk mesh. Hence, the combined mesh has four boundaries and their numbers correspond to those in the bulk mesh.

If we had set up the boundary lookup scheme in the surface mesh, the constructor of the combined {\ttfamily Mesh}, would have concatenated the boundary lookup schemes of the two sub-\/meshes so that the four boundaries in sub-\/mesh 0 would have become boundaries 0 to 3 in the combined mesh, while the two boundaries in the surface mesh would have become boundaries 4 and 5 in the combined {\ttfamily Mesh}. While the conversion is straightforward, it is obvious that {\ttfamily Mesh} boundaries are best identified via the sub-\/meshes.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysection{Post-\/processing}\label{index_doc}
The post-\/processing, implemented in {\ttfamily doc\+\_\+solution(...)} is now completely straightforward. Since the {\ttfamily Poisson\+Flux\+Elements} only apply boundary conditions, they do not have to be included in the plotting or error checking routines, so we perform these only for the elements in the bulk mesh.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments}{}\doxysection{Further comments}\label{index_comments}
We mentioned that the {\ttfamily Mesh} constructor that builds a combined {\ttfamily Mesh} from a vector of sub-\/meshes, concatenates the sub-\/meshes\textquotesingle{} element, node and boundary lookup schemes. There are a few additional features that the \char`\"{}user\char`\"{} should be aware of\+:
\begin{DoxyItemize}
\item The sub-\/meshes should not contain any duplicate nodes or elements. If they do, the function {\ttfamily Problem\+::build\+\_\+global\+\_\+mesh()} will issue a warning and ignore any duplicates. This is because the {\ttfamily Problem\textquotesingle{}s} global {\ttfamily Mesh} object is used by many functions in which operations must be performed exactly once for each node or element. For instance, in time-\/dependent problems, the function {\ttfamily Problem\+::shift\+\_\+time\+\_\+values()}, which is called automatically by {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)}, advances all \char`\"{}history values\char`\"{} by one time-\/level to prepare for the next timestep. If this was done repeatedly for nodes that are common to multiple sub-\/meshes, the results would be incorrect. If your problem requires a combined mesh in which duplicates are allowed, you must construct this mesh yourself.
\item Recall that the function {\ttfamily Mesh\+::add\+\_\+boundary\+\_\+node()} \char`\"{}tells\char`\"{} the mesh\textquotesingle{}s constituent nodes which boundaries they are located on. What happens if a (sub-\/)mesh for which this lookup scheme has been set up becomes part of a global {\ttfamily Mesh}? For various (good!) reasons, the {\ttfamily Mesh} constructor {\bfseries{does}} {\bfseries{not}} {\bfseries{update}} this information. The boundary number stored by the nodes therefore always refers to the boundary in the {\ttfamily Mesh} that created them. If this is not appropriate for your problem, you must construct the combined mesh yourself.
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc2/}{\texttt{ demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc2/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc2/two_d_poisson_flux_bc2.cc}{\texttt{ demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc2/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc2.\+cc }} \end{center} 
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
