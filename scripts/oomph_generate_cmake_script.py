#!/usr/bin/env python3

import os, re

# Define some variables for things that never change
script_header = """\
# ------------------------------------------------------------------------------
# Automatically generated by the script oomph_generate_cmake_script\n
"""
complex_script_header = """\
# ------------------------------------------------------------------------------
# NOTE: This was automatically generated by the oomph_generate_cmake_script
# script, but should be checked carefully as it contains a conditional statement
# or custom Automake recipe!
"""
script_footer = """\
# ------------------------------------------------------------------------------\
"""

def create_cmakelists_file(directory: str,
                           makefile_data: dict=None,
                           is_complex_makefile: bool=False) -> str:
    """Parses data from makefile_contents and uses the parsed data to create a
    CMakeLists.txt file.

    # To add self-test functionality see here:
    # https://stackoverflow.com/questions/19435375/simple-integration-testing-using-bash-with-cmake-and-ctest
    # add_test(NAME integration_test_01 COMMAND my_algorithm)

    """
    cmake_script = complex_script_header if is_complex_makefile else script_header

    if len(makefile_data["SUBDIRS"]):

        # Add the list of subdirectories
        cmake_script += f"set(SUBDIRS {' '.join(makefile_data['SUBDIRS'])})\n\n"
        cmake_script += f"foreach(SUBDIR ${{SUBDIRS}})\n"
        cmake_script += f"  add_subdirectory(${{SUBDIR}})\n"
        cmake_script += f"endforeach()\n\n"

    elif (len(makefile_data["check_PROGRAMS"]) or
          len(makefile_data["targets_info"])):

        # Add the preamble
        cmake_script += f"cmake_minimum_required(VERSION 3.22 FATAL_ERROR)\n"
        cmake_script += f"project({directory} C CXX Fortran)\n"
        cmake_script += f"find_package(oomphlib REQUIRED)\n\n"

        # Process the executables in alphabetical order
        targets_info = makefile_data["targets_info"]
        sorted_targets = sorted(targets_info.keys(), key=lambda x: x.lower())

        # Add in each executable
        for executable in sorted_targets:
            # for executable, executable_info in .items():
            executable_info = targets_info[executable]

            cmake_script += f"oomph_add_executable(\n"
            cmake_script += f"  TARGET {executable}\n"
            cmake_script += f"  SOURCES {' '.join(executable_info['SOURCES'])}\n"
            if executable_info.get("LDADD") is not None:
                cmake_script += f"  LIBRARIES {' '.join(executable_info['LDADD'])}\n"
            if executable_info.get("CXXFLAGS") is not None:
                cmake_script += f"  CXX_DEFINITIONS {' '.join(executable_info['CXXFLAGS'])}\n"
            cmake_script += f"  CXX_STANDARD 11)\n\n"

    else:
        raise ValueError(f"Not sure what to do in directory: {directory}")

    cmake_script += script_footer
    return cmake_script


def strip_prefix(text: str, substr: str) -> str:
    """Removes 'substr' from 'text' if 'text' contains it as a prefix."""
    text = text.lstrip()
    if text[:len(substr)] == substr:
        text = text[len(substr):]
    return text


def parse_makefile_data(directory: str, sanitised_makefile: str) -> dict:
    """Parses the sanitised Makefile data and processes the arguments to:
    SUBDIRS, check_PROGRAMS, *_SOURCES, *_LDADD (keep only libs with a lowercase
    -l flag), *_CXXFLAGS.
    """
    data = {
        "SUBDIRS": [],
        "check_PROGRAMS": [],
        "targets_info": {},
    }

    for line in sanitised_makefile.splitlines():
        # Parse the expression on this line
        known_expression = False
        expression = line.split("=")
        target, arguments = [x.strip() for x in expression]
        arguments = arguments.split(" ")

        if (target == "SUBDIRS") or (target == "check_PROGRAMS"):
            data[target] = arguments
            known_expression = True

        # Define lambdas for filtering the lib data
        libs_to_remove = ["-L@libdir@", "$(EXTERNAL_LIBS)", "$(FLIBS)"]
        libs_filter = (lambda x : x not in libs_to_remove)
        generic_filter = (lambda x : x != "-lgeneric")

        # Iterate over the info of each executables and filter the data
        exts = ["SOURCES", "LDADD", "CXXFLAGS"]
        for ext in exts:
            if target.find(ext) >= 0:
                # Filter/sanitise the data
                if ext == "SOURCES":
                    arguments = [arg for arg in arguments if arg != "validate.sh"]
                elif ext == "LDADD":
                    arguments = list(filter(libs_filter, arguments))
                    if len(arguments) > 1:
                        arguments = list(filter(generic_filter, arguments))
                    arguments = ["oomph::" + strip_prefix(arg, "-l") for arg in arguments]
                    print(arguments)
                elif ext == "CXXFLAGS":
                    arguments = [strip_prefix(arg, "-D") for arg in arguments]

                # Append the info
                executable_name = target.split("_" + ext)[0]
                if data["targets_info"].get(executable_name) is None:
                    data["targets_info"][executable_name] = {}
                data["targets_info"][executable_name][ext] = arguments

                # Indicate that we know what to do here
                known_expression = True

        # Print out the lines we don't know how to handle
        if known_expression == False:
            error_message = f"\nDon't know how to handle the expression:\n"
            error_message += f"   {expression}\n"
            error_message += f"In directory: {directory}\n"
            raise ValueError(error_message)

    return data


def sanitise_makefile(directory: str, makefile_path: str) -> str:

    # Read the file, replace newlines and tab characters with spaces and squeeze
    # multiple whitespaces into a single whitespace
    file_contents = open(makefile_path + "/Makefile.am", "r").read()
    file_contents = file_contents.replace("\\\n", " ").replace("\t", " ")
    file_contents = re.sub(' +', ' ', file_contents)

    # Remove empty lines and strip leading and trailing whitespaces
    file_contents = [line.strip() for line in file_contents.split('\n') if line.strip() != ""]

    # Remove comments
    contents_as_list = []
    for line in file_contents:
        index = line.find("#")
        if index == -1:
            # No comments => take whole line
            contents_as_list.append(line)
        elif index > 0:
            # The whole line isn't a comment so take the bit that isn't
            contents_as_list.append(line[:index])

    # Filters for the remaining crap. Note: We don't need to give a crap about
    # EXTRA_DIST -- CPack will package everything up, we only need to specify
    # what we DON'T want.
    filter_includes = lambda line : (line.find("include $(top_srcdir)") == -1)
    filter_cppflags = lambda line : (line.find("AM_CPPFLAGS") == -1)
    filter_extra_dist = lambda line : (line.find("EXTRA_DIST") == -1)
    contents_as_list = filter(filter_includes, contents_as_list)
    contents_as_list = filter(filter_cppflags, contents_as_list)
    contents_as_list = filter(filter_extra_dist, contents_as_list)
    return "\n".join(contents_as_list)


def is_simple_makefile(makefile_path: str) -> dict:
    """Returns True if a Makefile does not contain a conditional statement, as
    conditional statements require special attention. Returns False otherwise.
    """
    file_contents = open(makefile_path + "/Makefile.am", "r").read()

    # Remove comments
    contents_as_list = []
    for line in file_contents.splitlines():
        index = line.find("#")
        if index != -1:
            contents_as_list.append(line[:index])
        else:
            contents_as_list.append(line)
    file_contents = "\n".join(contents_as_list)

    # Determine whether the file is "simple"
    is_simple = True
    if file_contents.find("if ") >= 0:
        is_simple = False
    elif file_contents.find(":") >= 0:
        is_simple = False
        # print(file_contents)

    return is_simple


def get_makefile_paths(base_dir: str):
    """Walks through all of the subdirectories below base_dir and appends the
    path to each Makefile.am"""
    path_list = []
    for root, dirs, files in os.walk(base_dir, topdown=True):
        if "Makefile.am" in files:
            path_list.append(root)
    return path_list


def create_cmake_script_from_makefile(makefile_path: str,
                                      is_complex_makefile: bool=False) -> str:
    """Process a Makefile script and create a corresponding CMakeLists.txt file"""
    directory = os.path.basename(makefile_path)

    # Process the makefile and create the corresponding CMakeLists.txt file
    sanitised_makefile = sanitise_makefile(directory, makefile_path)
    makefile_dict = parse_makefile_data(directory, sanitised_makefile)
    cmake_script = create_cmakelists_file(
        directory, makefile_dict, is_complex_makefile)

    return cmake_script


def main():
    base_dir = os.getcwd()
    if (os.path.basename(base_dir) != "demo_drivers"):
        raise ValueError("Script needs to be run from the demo_drivers directory!")

    all_makefile_paths = get_makefile_paths(base_dir)
    simple_makefiles = [x for x in all_makefile_paths if is_simple_makefile(x)]
    complex_makefiles = [x for x in all_makefile_paths if not is_simple_makefile(x)]

    print("------------------ Handling simple makefiles ------------------")
    for makefile_path in simple_makefiles:
        # Process the makefile and create the corresponding CMakeLists.txt file
        cmake_script = create_cmake_script_from_makefile(
            makefile_path, is_complex_makefile=False)

        print(f"DIRECTORY: {makefile_path}")

        # # Output it...
        # cmake_file_path = makefile_path + "/CMakeLists.txt"
        # with open(cmake_file_path, "w") as f:
        #     print(cmake_script, file=f)

    print("\n\n")

    # print("------------------ Handling complex makefiles -----------------")
    # for makefile_path in complex_makefiles:
    #     # Process the makefile and create the corresponding CMakeLists.txt file
    #     cmake_script = create_cmake_script_from_makefile(
    #         makefile_path, is_complex_makefile=True)
    #
    #     print(f"DIRECTORY: {makefile_path}")
    #     print(open(f"{makefile_path}/Makefile.am", "r").read())
    #     print("*****************************************************")

    print("------------ List of makefiles I can't handle right now -----------")
    for makefile_path in complex_makefiles:
        rel_path = os.path.relpath(makefile_path, base_dir)
        if rel_path != ".":
            print(rel_path)


if __name__ == "__main__": main()